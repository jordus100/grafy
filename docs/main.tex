\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{fancyhdr} 
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{hyperref}

\title{Specyfikacja funkcjonalna programu na projekt CGrafy}
\author{Szymon Posiadała i Jordan Parviainen}
\date{03.03.2022r.}

\pagestyle{fancy}
\fancyhf{}

\lhead{\ifthenelse{\value{page}=1}{}{Specyfikacja funkcjonalna CGrafy}}
\rhead{\ifthenelse{\value{page}=1}{}{Szymon Posiadała i Jordan Parviainen}}
\cfoot{Strona \thepage \hspace{1pt} z \pageref{LastPage}}

\fancypagestyle{firststyle}
{
    \renewcommand{\headrulewidth}{0pt}
    \cfoot{Strona \thepage \hspace{1pt} z \pageref{LastPage}}
}

\setlength{\belowcaptionskip}{20pt}

\begin{document}
\maketitle

\thispagestyle{firststyle}
\section{Cel i opis projektu}
\subsection{Opis teorytyczny}
Nasz projekt ma na celu stworzenie programu realizującego pewne operacje dotyczące grafów skierowanych.\\
Graf skierowany to zbiór wierzchołków i łączących je krawędzi o określonym zwrocie i wadze (w naszym przypadku będącą liczbą rzeczywistą z zakresu od 0 do 1). Graf spójny to taki, w którym każda para wierzchołków połączona jest przynajmniej jedną krawędzią. Schemat przykładowego grafu można zobaczyć na Rysunku \ref{fig:schemat} w sekcji tego dokumentu 2.3 "Wejście".
\subsection{Opis funkcji programu}
\begin{enumerate}
\item Tworzenie grafu o podanej liczbie kolumn i wierszy oraz zapisywanie go do pliku tekstowego.
\item Losowanie krawędzi między wierzchołkami grafu oraz ich wagi w przedziale <0,10>.
\item Możliwość generowania grafu w 3 trybach:
\begin{itemize}
\item gdzie każdy wierzchołek jest połączony ze wszystkimi sąsiadami,
\item gdzie połączenia między wierzchołkami są generowane losowo a graf jest spójny,
\item zupełnie losowy, niekoniecznie spójny.
\end{itemize}
\item Sprawdzanie czy graf jest spójny algorytmem BFS,
\item znajdowanie najkrótszej drogi między dowolną ilością par dowolnie wybranych wierzchołków algorytmem Dijkstry,
\item Wyświetlanie najkrótszej drogi na 2 sposoby:
\begin{itemize}
\item podstawowy-wyświetlający długość drogi oraz kolejne wierzchołki do przejścia,
\item rozszerzony-wyświetlający dodatkowo wagę poszczególnych ruchów.
\end{itemize}

\end{enumerate}

\section{Instrukcja obsługi programu}

\subsection{Uruchomienie programu}
Pliki programu należy przenieść do środowiska systemowego Linux z zainstalowanym kompilatorem języka C oraz zainstalowanym programem Make.
Program należy najpierw skompilować poprzez użycie komendy \texttt{ make grafy }, znajdując się w głównym katalogu programu.
Następnie program można uruchomić używając komendy \texttt{ ./grafy } z odpowiednimi argumentami wywołania, wymienionymi w podsekcji tego dokumentu "Wejście".

\subsection{Wejście}
Wzór wywołania programu:
\texttt{ ./grafy [opcje wywołania] [argumenty wywołania] }
\\Opcje wywołania:
\begin{itemize}
%\item 2 dodatnie całkowite liczby-kolejno liczbę kolumn i wierszy dla wygenerowanego grafu
%\item OPCJONALNIE dowolną ilość par liczb między którymi chcemy znaleźć najkrótsze drogi
\item tryb w jakim chcemy wyświetlać najkrótsze drogi:
\begin{itemize}
    \item \texttt{-p} dla trybu podstawowego,
    \item \texttt{-r} dla trybu rozszerzonego.
\end{itemize}
\end{itemize}
Argumenty wywołania:
\begin{itemize}
\item \texttt{-f} \underline{NAZWA\_PLIKU}
\\Opis: pełna nazwa pliku opisującego graf zgodnie z formatem opisanym w sekcji tego dokumentu o numerze 2.3 \hyperref[sec:Wyjscie]{"Wyjscie"}. Uwaga: plik musi się znajdować w katalogu głównym programu.
\item \texttt{-n} \underline{LICZBA\_WIERSZY} \underline{LICZBA\_KOLUMN}
\\Opis: dodatnie liczby całkowite - kolejno liczba wierszy i kolumn grafu do wygenerowania. 
\item \texttt{-v [}\underline{NUMER\_WIERZCH} \ \ \underline{NUMER\_WIERZCH}\texttt{]} ... \texttt{[}\underline{NUMER\_WIERZCH} \ \ \underline{NUMER\_WIERZCH}\texttt{]}
\\Opis: dowolna ilość par liczb oznaczających wierzchołki między którymi chcemy znaleźć najkrótsze drogi (liczby muszą być całkowite, dodatnie i należeć do zakresu <0, liczba wierszy * liczba kolumn - 1>). Kolejne pary wierzchołków zamknięte są w nawiasach kwadratowych.

\end{itemize}
Wzory wywołania programu:
\begin{enumerate}
\item \texttt{./grafy [-p | -r] [-f \underline{NAZWA\_PLIKU} -v [\underline{NUMER\_WIERZCH} \ \underline{NUMER\_WIERZCH}] ... [\underline{NUMER\_WIERZCH} \ \underline{NUMER\_WIERZCH}]}
\item \texttt{./grafy -n \underline{LICZBA\_WIERSZY} \underline{LICZBA\_KOLUMN}}
\end{enumerate}
Oba te wzory się ze sobą nie łączą, gdyż program albo działa jako generator grafu, albo jako analizator grafu.
\\ \\Przykładowe wywołanie: \texttt{ ./grafy -p -f graf5 [1 10] [3 11] }
\\Wywołanie to uruchamia program w trybie podstawowego wyszukiwania najkrótszej drogi, wczytuje dane o grafie z pliku graf5 oraz wypisuje najkrótszą drogę między wierzchołkami 1 a 10 oraz między wierzchołkami 3 a 11.

\subsection{Wyjście}
\label{sec:Wyjscie}
Przy podaniu programowi ilości kolumn i wierszy program zwróci na standardowe wyjście wymiary stworzonego grafu oraz informację czy jest on spójny.
Jeśli podamy przy uruchamianiu plik wejściowy oraz numery wierzchołków między którymi chcemy znaleźć najkrótszą drogę, program wypisze numery wierzchołków oddzielone "->" oraz w trybie rozszerzonym wagę ścieżki do tego wierzchołka zapisaną w nawiasie. 

Dane o wygenerowanym grafie będą zapisywane do pliku graf.txt, zawierającego w pierwszej linii kolejno liczbę wierszy oraz liczbę kolumn. Każda kolejna będzie reprezentować kolejny wierzchołek grafu(zaczynając od zerowego) oraz jego drogi do kolejnych wierzchołków z przydzieloną wagą. 

Numeracja wierzchołków polega na nadawaniu im numeru będącego liczbą naturalną. Wierzchołek w lewym górnym rogu ma numer 0. Każdy kolejny wierzchołek ma numer będący liczbą większą o 1 od sąsiada znajdującego się po jego lewej stronie. W przypadku, gdy wierzchołek ten jest pierwszym od lewej w wierszu n, to dostaje numer o 1 większy niż wierzchołek w ostatniej kolumnie na prawo wiersza n-1. 
\newpage
Przykładowy plik graf.txt: 
\begin{tabbing}
\hspace{0em} \= \kill
    \>3 2\\
    \hspace{2em} \= \kill
	 \> 1 :0.88 \ 2 :0.21 \\
	 \> 3 :0.64 \ 0 :0.46  \\
	 \> 0 :0.86 \ 3 :0.42 4 :0.44\\
	 \> 1 :0.31 \ 2 :0.85 5 :0.77\\
	 \> 2 :0.48 \ 5 :0.35 \\
	 \> 3 :0.54 \ 4 :0.84 \\
\end{tabbing}
Powyższy przykładowy plik reprezentuje graf o wymiarze 3 wiersze x 2 kolumny.
\begin{figure}[h]
    \centering
    \caption{Schemat grafu z pokazaną konwencją numerowania wierzchołków}
    \includegraphics[scale=0.2]{Graf}
    \label{fig:schemat}
\end{figure}
\\Wierzchołek grafu nr 0 ma połączenie z wierzchołkiem numer 1 o wadze 0.88 i z wierzchołkiem nr 2 o wadze 0.21.\\
Wierzchołek grafu nr 1 ma połączenie z wierzchołkiem numer 3 o wadze 0.64 i z wierzchołkiem nr 0 o wadze 0.46.\\
Wierzchołek grafu nr 2 ma połączenie z wierzchołkiem numer 0 o wadze 0.86 , z wierzchołkiem nr 3 o wadze 0.42 i z wierzchołkiem nr 4 o wadze 0.44.\\
Analogicznie następne linijki pliku reprezentują kolejne wierzchołki grafu.

\subsection{Kody błędów}
Podanie innych argumentów niż przewidziane będzie skutkowało zwróceniem kodu błędu:
\begin{itemize}
\item 1 - nie podano poprawnie liczby kolumn i wierszy,
\item 2 - nie podano poprawnie par liczb do liczenia najkrótszej drogi,
\item 3 - podano nieprawidłowy plik z grafem do wczytania,
\item 4 - podano inny nieprawidłowy argument wywołania.
\end{itemize}

\section{Testy}
Testowane będą zarówno poszczególne moduły (każdy plik *.c któremu odpowiada plik nagłówkowy *.h), jak i konkretne funkcje w końcowej wersji programu.
Nazwy testów będą zawierać informacje o tym co sprawdzają oraz wynik testu (Okay/Not Okay).
Testy funkcji będą obejmować sprawdzenie poprawności zwracanej liczby kolumn i wierszy, spójności grafu, wartości najkrótszej drogi oraz reakcji na błędne argumenty wywołania.
\\Testy będą możliwe do uruchomienia podczas kompilacji (więcej szczegółów będzie dostępnych w Specyfikacji Implementacyjnej).

\end{document}